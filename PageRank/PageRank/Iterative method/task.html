<h2 style="text-align: center;">Theory</h2>

<p>We can see from the PageRank, the number of Procrastinating Pats that we expect to find on each website after long times. Putting them in order of popularity (based on this metric), the PageRank of this micro-internet is:</p>

<p><strong>C</strong>owRome, <strong>D</strong>roid, <strong>A</strong>pricot, <strong>F</strong>aceArea, <strong>B</strong>errysee, <strong>e</strong>Sales</p>

<p>Referring back to the micro-internet diagram, is this what you would have expected? Convince yourself that based on which pages seem important given which others link to them, that this is a sensible ranking.</p>

<p>In principle, we could use a linear algebra library, as in previous stage, to calculate the eigenvalues and vectors. And this would work for a small system. But this gets unmanageable for large systems. And since we only care about the principal eigenvector (the one with the largest eigenvalue, which will be 1 in this case), we can use the power <em>iteration method</em> which will scale better, and is faster for large systems.</p>

<p>Let's now try to get the same result using the Power-Iteration method. This method will be much better at dealing with large systems.</p>

<p>First let's set up our initial vector,  <span class="math-tex">\(r^{(0)}\)</span>, so that we have our 100 Procrastinating Pats equally distributed on each of our 6 websites.</p>

<pre><code class="language-python">r = 100 * np.ones(6) / 6</code></pre>

<p>To do one iteration the operations you can do this:</p>

<pre><code class="language-python">r = L @ r  # operator ‘@’ does matrix multiplication</code></pre>

<h2 style="text-align: center;">Description</h2>

<p>You need to:</p>

<p>1. Apply one step of the iteration method and print the vector with a precision of 3 decimal places.<br>
2. Apply the iteration method 10 times and print the vector with a precision of 3 decimals places.<br>
3. Apply the iteration method so that the difference between the <span class="math-tex">\(r^{(i)}\)</span> and <span class="math-tex">\(r^{(i+1)}\)</span> is not bigger than 0.01 and print the vector with a precision of 3 decimal places.</p>

<p>To check the difference between the <span class="math-tex">\(r^{(i)}\)</span> and <span class="math-tex">\(r^{(i+1)}\)</span> use the norm:</p>

<pre><code class="language-python">import numpy.linalg as la
la.norm(r_prev - r_next)</code></pre>

<p>If you add counting the number of iterations you will see how the PageRank order is established fairly quickly, and the vector converges on the value we calculated earlier after a few tens of repeats.</p>

<p>Congratulations! You've just calculated your first PageRank!</p>

<h2 style="text-align: center;">Example</h2>

<p>Example of your program output for this stage (6 numbers for each part)</p>

<pre><code class="language-no-highlight">13.889
19.444
30.556
25.000
5.556
5.556

16.965
11.330
33.973
22.641
3.781
11.310

16.981
11.321
33.962
22.642
3.774
11.321</code></pre>